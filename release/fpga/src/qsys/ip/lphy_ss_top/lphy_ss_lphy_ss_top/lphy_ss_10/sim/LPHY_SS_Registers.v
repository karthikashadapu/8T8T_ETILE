// -----------------------------------------------------------------------------
//  Generated by Magillem, from Arteris IPD division
//  Version: 5.16.0 (20230705092541_5.16.0)
//  Date   : 2024-11-12 05:04:09
// -----------------------------------------------------------------------------
//  Verilog Register Bank
// -----------------------------------------------------------------------------
//  Component Name: LPHY_SS_Registers
//  File Ref      : /nfs/site/disks/ceg_user_bkhantwa/ipxact/ip_xact_rdl/csrgen_output/_workspace_mrv_gen_py_/xmlProject/_local_copy_Vendor_Library_LPHY_SS_Registers_1.0.xml
//  Protocol      : AVALON
//  Wait State    : WS1_OUTPUT
// -----------------------------------------------------------------------------

module LPHY_SS_Registers(

   // frame_sync_frame_config.dl_start
   output reg frame_sync_frame_config_dl_start,
   // frame_sync_frame_config.ul_start
   output reg frame_sync_frame_config_ul_start,
   // dl_input_config.dl_input_sample
   output reg [15:0] dl_input_config_dl_input_sample,
   // dl_input_config.dl_input_sym
   output reg [4:0] dl_input_config_dl_input_sym,
   // dl_input_config.dl_input_sfn
   output reg [3:0] dl_input_config_dl_input_sfn,
   // dl_input_config.dl_input_rfn
   output reg dl_input_config_dl_input_rfn,
   // ul_input_config.ul_input_sample
   output reg [15:0] ul_input_config_ul_input_sample,
   // ul_input_config.ul_input_sym
   output reg [4:0] ul_input_config_ul_input_sym,
   // ul_input_config.ul_input_sfn
   output reg [3:0] ul_input_config_ul_input_sfn,
   // ul_input_config.ul_input_rfn
   output reg ul_input_config_ul_input_rfn,
   // reset_config.soft_reset
   output reg reset_config_soft_reset,
   // bw_config_cc1.bw_config_sel
   output reg [6:0] bw_config_cc1_bw_config_sel,
   // bw_config_cc1.cc1_disable
   output reg bw_config_cc1_cc1_disable,
   // bw_config_cc2.bw_config_sel
   output reg [6:0] bw_config_cc2_bw_config_sel,
   // bw_config_cc2.cc2_disable
   output reg bw_config_cc2_cc2_disable,
   // prb_blanking_ctrl.blanking_dis
   output reg prb_blanking_ctrl_blanking_dis,
   // cp_length.cp_length
   output reg [10:0] cp_length_cp_length,
   // fft_size.fft_size
   output reg [3:0] fft_size_fft_size,
   // ifft_l1_control.mux_select_l1
   output reg ifft_l1_control_mux_select_l1,
   // ifft_l1_control.ifft_dc_sc_en_l1
   output reg ifft_l1_control_ifft_dc_sc_en_l1,
   // ifft_l1_control.ifft_rc_enable_l1
   output reg ifft_l1_control_ifft_rc_enable_l1,
   // ifft_gain_l1.ifft_gain_l1
   output reg [31:0] ifft_gain_l1_ifft_gain_l1,
   // ifft_shift_l1.ifft_shift_l1
   output reg [3:0] ifft_shift_l1_ifft_shift_l1,
   // ifft_mux_const_data_l1.ifft_mux_constant_l1
   output reg [15:0] ifft_mux_const_data_l1_ifft_mux_constant_l1,
   // ifft_l2_control.mux_select_l2
   output reg ifft_l2_control_mux_select_l2,
   // ifft_l2_control.ifft_dc_sc_en_l2
   output reg ifft_l2_control_ifft_dc_sc_en_l2,
   // ifft_l2_control.ifft_rc_enable_l2
   output reg ifft_l2_control_ifft_rc_enable_l2,
   // ifft_gain_l2.ifft_gain_l2
   output reg [31:0] ifft_gain_l2_ifft_gain_l2,
   // ifft_shift_l2.ifft_shift_l2
   output reg [3:0] ifft_shift_l2_ifft_shift_l2,
   // ifft_mux_const_data_l2.ifft_mux_constant_l2
   output reg [15:0] ifft_mux_const_data_l2_ifft_mux_constant_l2,
   // fft_l1_control.fft_dc_sc_en_l1
   output reg fft_l1_control_fft_dc_sc_en_l1,
   // fft_l1_control.ul_hcs_bypass_l1
   output reg fft_l1_control_ul_hcs_bypass_l1,
   // fft_l1_control.fft_rc_enable_l1
   output reg fft_l1_control_fft_rc_enable_l1,
   // fft_gain_l1.fft_gain_l1
   output reg [31:0] fft_gain_l1_fft_gain_l1,
   // fft_shift_l1.fft_shift_l1
   output reg [3:0] fft_shift_l1_fft_shift_l1,
   // fft_l2_control.fft_dc_sc_en_l2
   output reg fft_l2_control_fft_dc_sc_en_l2,
   // fft_l2_control.ul_hcs_bypass_l2
   output reg fft_l2_control_ul_hcs_bypass_l2,
   // fft_l2_control.fft_rc_enable_l2
   output reg fft_l2_control_fft_rc_enable_l2,
   // fft_gain_l2.fft_gain_l2
   output reg [31:0] fft_gain_l2_fft_gain_l2,
   // fft_shift_l2.fft_shift_l2
   output reg [3:0] fft_shift_l2_fft_shift_l2,
   // lpbk_en.ifft_fft_lpbk_en
   output reg lpbk_en_ifft_fft_lpbk_en,
   // lpbk_en.duc_ddc_lpbk_en
   output reg lpbk_en_duc_ddc_lpbk_en,
   // c_hps.c_hps
   output reg c_hps_c_hps,
   // prach_sel.short_long_prach_sel
   input wire prach_sel_short_long_prach_sel_i,
   // long_prach_freq_offset.long_prach_freq_offset
   input wire [23:0] long_prach_freq_offset_long_prach_freq_offset_i,
   // long_prach_filt_flush_en.lprach1_filt_flush_en
   output reg long_prach_filt_flush_en_lprach1_filt_flush_en,
   // long_prach_filt_flush_en.lprach2_filt_flush_en
   output reg long_prach_filt_flush_en_lprach2_filt_flush_en,
   // long_prach_version.long_prach_version
   input wire [31:0] long_prach_version_long_prach_version_i,
   // num_cc.num_cc
   input wire num_cc_num_cc_i,
   // prach_pat_en.prach_pat_en
   output reg prach_pat_en_prach_pat_en,
   // prach_pb_sel.prach_pb_sel
   output reg prach_pb_sel_prach_pb_sel,
   // hps_valid.hps_valid
   output reg hps_valid_hps_valid,
   // hps_config.frame_structure
   output reg [7:0] hps_config_frame_structure,
   // short_prach_freq_offset.short_prach_freq_offset
   output reg [23:0] short_prach_freq_offset_short_prach_freq_offset,
   // ifft_l1_rc_bw_sel.ifft_rc_bw_sel_l1
   output reg [3:0] ifft_l1_rc_bw_sel_ifft_rc_bw_sel_l1,
   // ifft_l2_rc_bw_sel.ifft_rc_bw_sel_l2
   output reg [3:0] ifft_l2_rc_bw_sel_ifft_rc_bw_sel_l2,
   // fft_l1_rc_bw_sel.fft_rc_bw_sel_l1
   output reg [3:0] fft_l1_rc_bw_sel_fft_rc_bw_sel_l1,
   // fft_l2_rc_bw_sel.fft_rc_bw_sel_l2
   output reg [3:0] fft_l2_rc_bw_sel_fft_rc_bw_sel_l2,
   // short_prach_time_offset.short_prach_time_offset
   output reg [31:0] short_prach_time_offset_short_prach_time_offset,
   // short_prach_time_offset_bias.short_prach_time_offset_bias
   output reg [31:0] short_prach_time_offset_bias_short_prach_time_offset_bias,
   // short_prach_startsym_bias.short_prach_startsym_bias
   output reg [31:0] short_prach_startsym_bias_short_prach_startsym_bias,

   // Bus interface
   input wire clk,
   input wire reset,
   input wire [31:0] writedata,
   input wire read,
   input wire write,
   input wire [3:0] byteenable,
   output reg [31:0] readdata,
   output reg readdatavalid,
   input wire [7:0] address
);

wire reset_n = !reset;

// -----------------------------------------------------------------------------
// Protocol management
// -----------------------------------------------------------------------------

reg [31:0] rdata_comb;
always @(negedge reset_n, posedge clk)
   if (!reset_n) readdata[31:0] <= 32'h00000000; else readdata[31:0] <= rdata_comb[31:0];

// Read data is always valid the cycle after read transaction is asserted
always @(negedge reset_n, posedge clk)
   if (!reset_n) readdatavalid <= 1'b0; else readdatavalid <= read;

wire we = write;
wire re = read;
wire [7:0] addr = address[7:0];
wire [31:0] din = writedata[31:0];

// -----------------------------------------------------------------------------
// Write byte enables
// -----------------------------------------------------------------------------

// Register frame_sync_frame_config
wire we_frame_sync_frame_config = we & (addr[7:0] == 8'h00) ? byteenable[0] : 1'b0;
// Register dl_input_config
wire [3:0] we_dl_input_config = we & (addr[7:0] == 8'h04) ? byteenable[3:0] : {4{1'b0}};
// Register ul_input_config
wire [3:0] we_ul_input_config = we & (addr[7:0] == 8'h08) ? byteenable[3:0] : {4{1'b0}};
// Register reset_config
wire we_reset_config = we & (addr[7:0] == 8'h0c) ? byteenable[0] : 1'b0;
// Register bw_config_cc1
wire we_bw_config_cc1 = we & (addr[7:0] == 8'h10) ? byteenable[0] : 1'b0;
// Register bw_config_cc2
wire we_bw_config_cc2 = we & (addr[7:0] == 8'h14) ? byteenable[0] : 1'b0;
// Register prb_blanking_ctrl
wire we_prb_blanking_ctrl = we & (addr[7:0] == 8'h18) ? byteenable[0] : 1'b0;
// Register cp_length
wire [1:0] we_cp_length = we & (addr[7:0] == 8'h1c) ? byteenable[1:0] : {2{1'b0}};
// Register fft_size
wire we_fft_size = we & (addr[7:0] == 8'h20) ? byteenable[0] : 1'b0;
// Register ifft_l1_control
wire we_ifft_l1_control = we & (addr[7:0] == 8'h24) ? byteenable[0] : 1'b0;
// Register ifft_gain_l1
wire [3:0] we_ifft_gain_l1 = we & (addr[7:0] == 8'h28) ? byteenable[3:0] : {4{1'b0}};
// Register ifft_shift_l1
wire we_ifft_shift_l1 = we & (addr[7:0] == 8'h2c) ? byteenable[0] : 1'b0;
// Register ifft_mux_const_data_l1
wire [1:0] we_ifft_mux_const_data_l1 = we & (addr[7:0] == 8'h30) ? byteenable[1:0] : {2{1'b0}};
// Register ifft_l2_control
wire we_ifft_l2_control = we & (addr[7:0] == 8'h38) ? byteenable[0] : 1'b0;
// Register ifft_gain_l2
wire [3:0] we_ifft_gain_l2 = we & (addr[7:0] == 8'h3c) ? byteenable[3:0] : {4{1'b0}};
// Register ifft_shift_l2
wire we_ifft_shift_l2 = we & (addr[7:0] == 8'h40) ? byteenable[0] : 1'b0;
// Register ifft_mux_const_data_l2
wire [1:0] we_ifft_mux_const_data_l2 = we & (addr[7:0] == 8'h44) ? byteenable[1:0] : {2{1'b0}};
// Register fft_l1_control
wire we_fft_l1_control = we & (addr[7:0] == 8'h4c) ? byteenable[0] : 1'b0;
// Register fft_gain_l1
wire [3:0] we_fft_gain_l1 = we & (addr[7:0] == 8'h50) ? byteenable[3:0] : {4{1'b0}};
// Register fft_shift_l1
wire we_fft_shift_l1 = we & (addr[7:0] == 8'h54) ? byteenable[0] : 1'b0;
// Register fft_l2_control
wire we_fft_l2_control = we & (addr[7:0] == 8'h58) ? byteenable[0] : 1'b0;
// Register fft_gain_l2
wire [3:0] we_fft_gain_l2 = we & (addr[7:0] == 8'h5c) ? byteenable[3:0] : {4{1'b0}};
// Register fft_shift_l2
wire we_fft_shift_l2 = we & (addr[7:0] == 8'h60) ? byteenable[0] : 1'b0;
// Register lpbk_en
wire we_lpbk_en = we & (addr[7:0] == 8'h64) ? byteenable[0] : 1'b0;
// Register c_hps
wire we_c_hps = we & (addr[7:0] == 8'h68) ? byteenable[0] : 1'b0;
// Register long_prach_filt_flush_en
wire we_long_prach_filt_flush_en = we & (addr[7:0] == 8'h74) ? byteenable[0] : 1'b0;
// Register prach_pat_en
wire we_prach_pat_en = we & (addr[7:0] == 8'h80) ? byteenable[0] : 1'b0;
// Register prach_pb_sel
wire we_prach_pb_sel = we & (addr[7:0] == 8'h84) ? byteenable[0] : 1'b0;
// Register hps_valid
wire we_hps_valid = we & (addr[7:0] == 8'h88) ? byteenable[0] : 1'b0;
// Register hps_config
wire we_hps_config = we & (addr[7:0] == 8'h8c) ? byteenable[0] : 1'b0;
// Register short_prach_freq_offset
wire [2:0] we_short_prach_freq_offset = we & (addr[7:0] == 8'h90) ? byteenable[2:0] : {3{1'b0}};
// Register ifft_l1_rc_bw_sel
wire we_ifft_l1_rc_bw_sel = we & (addr[7:0] == 8'h94) ? byteenable[0] : 1'b0;
// Register ifft_l2_rc_bw_sel
wire we_ifft_l2_rc_bw_sel = we & (addr[7:0] == 8'h98) ? byteenable[0] : 1'b0;
// Register fft_l1_rc_bw_sel
wire we_fft_l1_rc_bw_sel = we & (addr[7:0] == 8'h9c) ? byteenable[0] : 1'b0;
// Register fft_l2_rc_bw_sel
wire we_fft_l2_rc_bw_sel = we & (addr[7:0] == 8'ha0) ? byteenable[0] : 1'b0;
// Register short_prach_time_offset
wire [3:0] we_short_prach_time_offset = we & (addr[7:0] == 8'ha4) ? byteenable[3:0] : {4{1'b0}};
// Register short_prach_time_offset_bias
wire [3:0] we_short_prach_time_offset_bias = we & (addr[7:0] == 8'ha8) ? byteenable[3:0] : {4{1'b0}};
// Register short_prach_startsym_bias
wire [3:0] we_short_prach_startsym_bias = we & (addr[7:0] == 8'hac) ? byteenable[3:0] : {4{1'b0}};

// -----------------------------------------------------------------------------
// Read byte enables
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Register frame_sync_frame_config implementation
// -----------------------------------------------------------------------------

// frame_sync_frame_config_dl_start
//    bitfield description: Bit 0 - DL start
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      frame_sync_frame_config_dl_start <= 1'h0;
   end
   else begin
      if (we_frame_sync_frame_config) begin
         frame_sync_frame_config_dl_start <= din[0];
      end
   end

// frame_sync_frame_config_ul_start
//    bitfield description: Bit 1 - UL Start
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      frame_sync_frame_config_ul_start <= 1'h0;
   end
   else begin
      if (we_frame_sync_frame_config) begin
         frame_sync_frame_config_ul_start <= din[1];
      end
   end

// -----------------------------------------------------------------------------
// Register dl_input_config implementation
// -----------------------------------------------------------------------------

// dl_input_config_dl_input_sample
//    bitfield description: Bit [15:0] - DL Input Sample Count
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 16'h0000

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      dl_input_config_dl_input_sample <= 16'h0000;
   end
   else begin
      if (we_dl_input_config[0]) begin
         dl_input_config_dl_input_sample[7:0] <= din[7:0];
      end
      if (we_dl_input_config[1]) begin
         dl_input_config_dl_input_sample[15:8] <= din[15:8];
      end
   end

// dl_input_config_dl_input_sym
//    bitfield description: Bit [20:16] - DL Input Symbol Count
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 5'h00

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      dl_input_config_dl_input_sym <= 5'h00;
   end
   else begin
      if (we_dl_input_config[2]) begin
         dl_input_config_dl_input_sym[4:0] <= din[20:16];
      end
   end

// dl_input_config_dl_input_sfn
//    bitfield description: Bit [24:21] - DL Input Subframe Number
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 4'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      dl_input_config_dl_input_sfn <= 4'h0;
   end
   else begin
      if (we_dl_input_config[2]) begin
         dl_input_config_dl_input_sfn[2:0] <= din[23:21];
      end
      if (we_dl_input_config[3]) begin
         dl_input_config_dl_input_sfn[3] <= din[24];
      end
   end

// dl_input_config_dl_input_rfn
//    bitfield description: Bit [25] - DL Input Radio Frame Number
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      dl_input_config_dl_input_rfn <= 1'h0;
   end
   else begin
      if (we_dl_input_config[3]) begin
         dl_input_config_dl_input_rfn <= din[25];
      end
   end

// -----------------------------------------------------------------------------
// Register ul_input_config implementation
// -----------------------------------------------------------------------------

// ul_input_config_ul_input_sample
//    bitfield description: Bit [15:0] - UL Input Sample Count
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 16'h0000

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ul_input_config_ul_input_sample <= 16'h0000;
   end
   else begin
      if (we_ul_input_config[0]) begin
         ul_input_config_ul_input_sample[7:0] <= din[7:0];
      end
      if (we_ul_input_config[1]) begin
         ul_input_config_ul_input_sample[15:8] <= din[15:8];
      end
   end

// ul_input_config_ul_input_sym
//    bitfield description: Bit [20:16] - UL Input Symbol Count
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 5'h00

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ul_input_config_ul_input_sym <= 5'h00;
   end
   else begin
      if (we_ul_input_config[2]) begin
         ul_input_config_ul_input_sym[4:0] <= din[20:16];
      end
   end

// ul_input_config_ul_input_sfn
//    bitfield description: Bit [24:21] - UL Input Subframe Number
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 4'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ul_input_config_ul_input_sfn <= 4'h0;
   end
   else begin
      if (we_ul_input_config[2]) begin
         ul_input_config_ul_input_sfn[2:0] <= din[23:21];
      end
      if (we_ul_input_config[3]) begin
         ul_input_config_ul_input_sfn[3] <= din[24];
      end
   end

// ul_input_config_ul_input_rfn
//    bitfield description: Bit [25] - UL Input Radio Frame Number
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ul_input_config_ul_input_rfn <= 1'h0;
   end
   else begin
      if (we_ul_input_config[3]) begin
         ul_input_config_ul_input_rfn <= din[25];
      end
   end

// -----------------------------------------------------------------------------
// Register reset_config implementation
// -----------------------------------------------------------------------------

// reset_config_soft_reset
//    bitfield description: bit[0]- enable/disable soft reset
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h1

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      reset_config_soft_reset <= 1'h1;
   end
   else begin
      if (we_reset_config) begin
         reset_config_soft_reset <= din[0];
      end
   end

// -----------------------------------------------------------------------------
// Register bw_config_cc1 implementation
// -----------------------------------------------------------------------------

// bw_config_cc1_bw_config_sel
//    bitfield description: Bit [6:0] - BW Selection
//                          // 'hA - 60 MHz BW
//                          // 'hE-100 MHz BW
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 7'h0e

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      bw_config_cc1_bw_config_sel <= 7'h0e;
   end
   else begin
      if (we_bw_config_cc1) begin
         bw_config_cc1_bw_config_sel[6:0] <= din[6:0];
      end
   end

// bw_config_cc1_cc1_disable
//    bitfield description: Bit [7] - CC Disable
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      bw_config_cc1_cc1_disable <= 1'h0;
   end
   else begin
      if (we_bw_config_cc1) begin
         bw_config_cc1_cc1_disable <= din[7];
      end
   end

// -----------------------------------------------------------------------------
// Register bw_config_cc2 implementation
// -----------------------------------------------------------------------------

// bw_config_cc2_bw_config_sel
//    bitfield description: Bit [6:0] - BW Selection
//                          // 'hA - 60 MHz BW
//                          // 'hE-100 MHz BW
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 7'h0e

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      bw_config_cc2_bw_config_sel <= 7'h0e;
   end
   else begin
      if (we_bw_config_cc2) begin
         bw_config_cc2_bw_config_sel[6:0] <= din[6:0];
      end
   end

// bw_config_cc2_cc2_disable
//    bitfield description: Bit [7] - CC Disable
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      bw_config_cc2_cc2_disable <= 1'h0;
   end
   else begin
      if (we_bw_config_cc2) begin
         bw_config_cc2_cc2_disable <= din[7];
      end
   end

// -----------------------------------------------------------------------------
// Register prb_blanking_ctrl implementation
// -----------------------------------------------------------------------------

// prb_blanking_ctrl_blanking_dis
//    bitfield description: Bit[0]- enable/disable blanking
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      prb_blanking_ctrl_blanking_dis <= 1'h0;
   end
   else begin
      if (we_prb_blanking_ctrl) begin
         prb_blanking_ctrl_blanking_dis <= din[0];
      end
   end

// -----------------------------------------------------------------------------
// Register cp_length implementation
// -----------------------------------------------------------------------------

// cp_length_cp_length
//    bitfield description: Bit [10:0] - cp length
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 11'h160

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      cp_length_cp_length <= 11'h160;
   end
   else begin
      if (we_cp_length[0]) begin
         cp_length_cp_length[7:0] <= din[7:0];
      end
      if (we_cp_length[1]) begin
         cp_length_cp_length[10:8] <= din[10:8];
      end
   end

// -----------------------------------------------------------------------------
// Register fft_size implementation
// -----------------------------------------------------------------------------

// fft_size_fft_size
//    bitfield description: FFT size Bits [3:0] - fft size
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 4'hc

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      fft_size_fft_size <= 4'hc;
   end
   else begin
      if (we_fft_size) begin
         fft_size_fft_size[3:0] <= din[3:0];
      end
   end

// -----------------------------------------------------------------------------
// Register ifft_l1_control implementation
// -----------------------------------------------------------------------------

// ifft_l1_control_mux_select_l1
//    bitfield description: Bit [0] - mux select/deselect for ifft L1.
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ifft_l1_control_mux_select_l1 <= 1'h0;
   end
   else begin
      if (we_ifft_l1_control) begin
         ifft_l1_control_mux_select_l1 <= din[0];
      end
   end

// ifft_l1_control_ifft_dc_sc_en_l1
//    bitfield description: Bit [1] - dc subcarrier enable/disable for ifft L1.
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h1

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ifft_l1_control_ifft_dc_sc_en_l1 <= 1'h1;
   end
   else begin
      if (we_ifft_l1_control) begin
         ifft_l1_control_ifft_dc_sc_en_l1 <= din[1];
      end
   end

// ifft_l1_control_ifft_rc_enable_l1
//    bitfield description: Bit[2]- RC enable/disable for ifft L1
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ifft_l1_control_ifft_rc_enable_l1 <= 1'h0;
   end
   else begin
      if (we_ifft_l1_control) begin
         ifft_l1_control_ifft_rc_enable_l1 <= din[2];
      end
   end

// -----------------------------------------------------------------------------
// Register ifft_gain_l1 implementation
// -----------------------------------------------------------------------------

// ifft_gain_l1_ifft_gain_l1
//    bitfield description: iFFT Gain L1: Bits [31:16] - iFFT gain imag, Bits [15:0] - iFFT gain real
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 32'h00004000

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ifft_gain_l1_ifft_gain_l1 <= 32'h00004000;
   end
   else begin
      if (we_ifft_gain_l1[0]) begin
         ifft_gain_l1_ifft_gain_l1[7:0] <= din[7:0];
      end
      if (we_ifft_gain_l1[1]) begin
         ifft_gain_l1_ifft_gain_l1[15:8] <= din[15:8];
      end
      if (we_ifft_gain_l1[2]) begin
         ifft_gain_l1_ifft_gain_l1[23:16] <= din[23:16];
      end
      if (we_ifft_gain_l1[3]) begin
         ifft_gain_l1_ifft_gain_l1[31:24] <= din[31:24];
      end
   end

// -----------------------------------------------------------------------------
// Register ifft_shift_l1 implementation
// -----------------------------------------------------------------------------

// ifft_shift_l1_ifft_shift_l1
//    bitfield description: Bits [3:0] - iFFT shift
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 4'hc

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ifft_shift_l1_ifft_shift_l1 <= 4'hc;
   end
   else begin
      if (we_ifft_shift_l1) begin
         ifft_shift_l1_ifft_shift_l1[3:0] <= din[3:0];
      end
   end

// -----------------------------------------------------------------------------
// Register ifft_mux_const_data_l1 implementation
// -----------------------------------------------------------------------------

// ifft_mux_const_data_l1_ifft_mux_constant_l1
//    bitfield description: Bits [15:0] - iFFT mux constant for L1
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 16'h0000

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ifft_mux_const_data_l1_ifft_mux_constant_l1 <= 16'h0000;
   end
   else begin
      if (we_ifft_mux_const_data_l1[0]) begin
         ifft_mux_const_data_l1_ifft_mux_constant_l1[7:0] <= din[7:0];
      end
      if (we_ifft_mux_const_data_l1[1]) begin
         ifft_mux_const_data_l1_ifft_mux_constant_l1[15:8] <= din[15:8];
      end
   end

// -----------------------------------------------------------------------------
// Register ifft_l2_control implementation
// -----------------------------------------------------------------------------

// ifft_l2_control_mux_select_l2
//    bitfield description: Bit [0] - mux select/deselect for ifft L2
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ifft_l2_control_mux_select_l2 <= 1'h0;
   end
   else begin
      if (we_ifft_l2_control) begin
         ifft_l2_control_mux_select_l2 <= din[0];
      end
   end

// ifft_l2_control_ifft_dc_sc_en_l2
//    bitfield description: Bit [1] - dc subcarrier enable/disable for ifft L2.
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h1

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ifft_l2_control_ifft_dc_sc_en_l2 <= 1'h1;
   end
   else begin
      if (we_ifft_l2_control) begin
         ifft_l2_control_ifft_dc_sc_en_l2 <= din[1];
      end
   end

// ifft_l2_control_ifft_rc_enable_l2
//    bitfield description: Bit[2]- RC enable/disable for ifft L2
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ifft_l2_control_ifft_rc_enable_l2 <= 1'h0;
   end
   else begin
      if (we_ifft_l2_control) begin
         ifft_l2_control_ifft_rc_enable_l2 <= din[2];
      end
   end

// -----------------------------------------------------------------------------
// Register ifft_gain_l2 implementation
// -----------------------------------------------------------------------------

// ifft_gain_l2_ifft_gain_l2
//    bitfield description: iFFT Gain L2: Bits [31:16] - iFFT gain imag, Bits [15:0] - iFFT gain real
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 32'h00004000

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ifft_gain_l2_ifft_gain_l2 <= 32'h00004000;
   end
   else begin
      if (we_ifft_gain_l2[0]) begin
         ifft_gain_l2_ifft_gain_l2[7:0] <= din[7:0];
      end
      if (we_ifft_gain_l2[1]) begin
         ifft_gain_l2_ifft_gain_l2[15:8] <= din[15:8];
      end
      if (we_ifft_gain_l2[2]) begin
         ifft_gain_l2_ifft_gain_l2[23:16] <= din[23:16];
      end
      if (we_ifft_gain_l2[3]) begin
         ifft_gain_l2_ifft_gain_l2[31:24] <= din[31:24];
      end
   end

// -----------------------------------------------------------------------------
// Register ifft_shift_l2 implementation
// -----------------------------------------------------------------------------

// ifft_shift_l2_ifft_shift_l2
//    bitfield description: Bits [3:0] - iFFT shift
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 4'hc

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ifft_shift_l2_ifft_shift_l2 <= 4'hc;
   end
   else begin
      if (we_ifft_shift_l2) begin
         ifft_shift_l2_ifft_shift_l2[3:0] <= din[3:0];
      end
   end

// -----------------------------------------------------------------------------
// Register ifft_mux_const_data_l2 implementation
// -----------------------------------------------------------------------------

// ifft_mux_const_data_l2_ifft_mux_constant_l2
//    bitfield description: Bits [15:0] - iFFT mux constant for L2
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 16'h0000

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ifft_mux_const_data_l2_ifft_mux_constant_l2 <= 16'h0000;
   end
   else begin
      if (we_ifft_mux_const_data_l2[0]) begin
         ifft_mux_const_data_l2_ifft_mux_constant_l2[7:0] <= din[7:0];
      end
      if (we_ifft_mux_const_data_l2[1]) begin
         ifft_mux_const_data_l2_ifft_mux_constant_l2[15:8] <= din[15:8];
      end
   end

// -----------------------------------------------------------------------------
// Register fft_l1_control implementation
// -----------------------------------------------------------------------------

// fft_l1_control_fft_dc_sc_en_l1
//    bitfield description: Bit [0] - dc subcarrier enable/disable for fft L1.
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h1

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      fft_l1_control_fft_dc_sc_en_l1 <= 1'h1;
   end
   else begin
      if (we_fft_l1_control) begin
         fft_l1_control_fft_dc_sc_en_l1 <= din[0];
      end
   end

// fft_l1_control_ul_hcs_bypass_l1
//    bitfield description: Bit [1] - HCS bypass fft l1
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      fft_l1_control_ul_hcs_bypass_l1 <= 1'h0;
   end
   else begin
      if (we_fft_l1_control) begin
         fft_l1_control_ul_hcs_bypass_l1 <= din[1];
      end
   end

// fft_l1_control_fft_rc_enable_l1
//    bitfield description: Bit[2]- RC enable/disable for fft L1
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      fft_l1_control_fft_rc_enable_l1 <= 1'h0;
   end
   else begin
      if (we_fft_l1_control) begin
         fft_l1_control_fft_rc_enable_l1 <= din[2];
      end
   end

// -----------------------------------------------------------------------------
// Register fft_gain_l1 implementation
// -----------------------------------------------------------------------------

// fft_gain_l1_fft_gain_l1
//    bitfield description: FFT Gain L1 Bits [31:16] - FFT gain imag, Bits[15:0] - FFT gain real
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 32'h00004000

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      fft_gain_l1_fft_gain_l1 <= 32'h00004000;
   end
   else begin
      if (we_fft_gain_l1[0]) begin
         fft_gain_l1_fft_gain_l1[7:0] <= din[7:0];
      end
      if (we_fft_gain_l1[1]) begin
         fft_gain_l1_fft_gain_l1[15:8] <= din[15:8];
      end
      if (we_fft_gain_l1[2]) begin
         fft_gain_l1_fft_gain_l1[23:16] <= din[23:16];
      end
      if (we_fft_gain_l1[3]) begin
         fft_gain_l1_fft_gain_l1[31:24] <= din[31:24];
      end
   end

// -----------------------------------------------------------------------------
// Register fft_shift_l1 implementation
// -----------------------------------------------------------------------------

// fft_shift_l1_fft_shift_l1
//    bitfield description: Number of Bits to right shift before FFT operation
//                          // Bits [3:0] - FFT shift
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 4'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      fft_shift_l1_fft_shift_l1 <= 4'h0;
   end
   else begin
      if (we_fft_shift_l1) begin
         fft_shift_l1_fft_shift_l1[3:0] <= din[3:0];
      end
   end

// -----------------------------------------------------------------------------
// Register fft_l2_control implementation
// -----------------------------------------------------------------------------

// fft_l2_control_fft_dc_sc_en_l2
//    bitfield description: Bit [0] - dc subcarrier enable/disable for fft L2.
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h1

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      fft_l2_control_fft_dc_sc_en_l2 <= 1'h1;
   end
   else begin
      if (we_fft_l2_control) begin
         fft_l2_control_fft_dc_sc_en_l2 <= din[0];
      end
   end

// fft_l2_control_ul_hcs_bypass_l2
//    bitfield description: Bit [1] - HCS bypass fft l2.
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      fft_l2_control_ul_hcs_bypass_l2 <= 1'h0;
   end
   else begin
      if (we_fft_l2_control) begin
         fft_l2_control_ul_hcs_bypass_l2 <= din[1];
      end
   end

// fft_l2_control_fft_rc_enable_l2
//    bitfield description: Bit[2]- RC enable/disable for fft L2
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      fft_l2_control_fft_rc_enable_l2 <= 1'h0;
   end
   else begin
      if (we_fft_l2_control) begin
         fft_l2_control_fft_rc_enable_l2 <= din[2];
      end
   end

// -----------------------------------------------------------------------------
// Register fft_gain_l2 implementation
// -----------------------------------------------------------------------------

// fft_gain_l2_fft_gain_l2
//    bitfield description: FFT Gain L2 Bits [31:16] - FFT gain imag, Bits[15:0] - FFT gain real
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 32'h00004000

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      fft_gain_l2_fft_gain_l2 <= 32'h00004000;
   end
   else begin
      if (we_fft_gain_l2[0]) begin
         fft_gain_l2_fft_gain_l2[7:0] <= din[7:0];
      end
      if (we_fft_gain_l2[1]) begin
         fft_gain_l2_fft_gain_l2[15:8] <= din[15:8];
      end
      if (we_fft_gain_l2[2]) begin
         fft_gain_l2_fft_gain_l2[23:16] <= din[23:16];
      end
      if (we_fft_gain_l2[3]) begin
         fft_gain_l2_fft_gain_l2[31:24] <= din[31:24];
      end
   end

// -----------------------------------------------------------------------------
// Register fft_shift_l2 implementation
// -----------------------------------------------------------------------------

// fft_shift_l2_fft_shift_l2
//    bitfield description: Number of Bits to right shift before FFT operation
//                          // Bits [3:0] - FFT shift
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 4'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      fft_shift_l2_fft_shift_l2 <= 4'h0;
   end
   else begin
      if (we_fft_shift_l2) begin
         fft_shift_l2_fft_shift_l2[3:0] <= din[3:0];
      end
   end

// -----------------------------------------------------------------------------
// Register lpbk_en implementation
// -----------------------------------------------------------------------------

// lpbk_en_ifft_fft_lpbk_en
//    bitfield description: Bit [1] - duc - ddc loopback enable, Bit [0] - ifft-fft loopback enable
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      lpbk_en_ifft_fft_lpbk_en <= 1'h0;
	  lpbk_en_duc_ddc_lpbk_en  <= 1'h0;
   end
   else begin
      if (we_lpbk_en) begin
         lpbk_en_ifft_fft_lpbk_en <= din[0];
		 lpbk_en_duc_ddc_lpbk_en  <= din[1];
      end
   end
   


// -----------------------------------------------------------------------------
// Register c_hps implementation
// -----------------------------------------------------------------------------

// c_hps_c_hps
//    bitfield description: Set value 0 for C Plane and 1 for HPS
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h1

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      c_hps_c_hps <= 1'h1;
   end
   else begin
      if (we_c_hps) begin
         c_hps_c_hps <= din[0];
      end
   end

// -----------------------------------------------------------------------------
// Register prach_sel implementation
// -----------------------------------------------------------------------------

// prach_sel_short_long_prach_sel
//    customType : RO
//    hwAccess   : WO
//    reset value: 1'h1
//    inputPort  : prach_sel_short_long_prach_sel_i
//
// No register generated

// -----------------------------------------------------------------------------
// Register long_prach_freq_offset implementation
// -----------------------------------------------------------------------------

// long_prach_freq_offset_long_prach_freq_offset
//    bitfield description: Bits [23:0] long prach freq offset value from C-plane
//    customType          : RO
//    hwAccess            : WO
//    reset value         : 24'h000000
//    inputPort           : long_prach_freq_offset_long_prach_freq_offset_i
//
// No register generated

// -----------------------------------------------------------------------------
// Register long_prach_filt_flush_en implementation
// -----------------------------------------------------------------------------

// long_prach_filt_flush_en_lprach1_filt_flush_en
//    bitfield description: PRACH inst 0- BIT[0]
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      long_prach_filt_flush_en_lprach1_filt_flush_en <= 1'h0;
   end
   else begin
      if (we_long_prach_filt_flush_en) begin
         long_prach_filt_flush_en_lprach1_filt_flush_en <= din[0];
      end
   end

// long_prach_filt_flush_en_lprach2_filt_flush_en
//    bitfield description: PRACH inst 1- BIT[1]
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      long_prach_filt_flush_en_lprach2_filt_flush_en <= 1'h0;
   end
   else begin
      if (we_long_prach_filt_flush_en) begin
         long_prach_filt_flush_en_lprach2_filt_flush_en <= din[1];
      end
   end

// -----------------------------------------------------------------------------
// Register long_prach_version implementation
// -----------------------------------------------------------------------------

// long_prach_version_long_prach_version
//    bitfield description: Long PRACH version
//    customType          : RO
//    hwAccess            : WO
//    reset value         : 32'h00000000
//    inputPort           : long_prach_version_long_prach_version_i
//
// No register generated

// -----------------------------------------------------------------------------
// Register num_cc implementation
// -----------------------------------------------------------------------------

// num_cc_num_cc
//    bitfield description: Bit[31:1]-Reserved bits , Bit[0]- number of cc is one or two
//    customType          : RO
//    hwAccess            : WO
//    reset value         : 1'h0
//    inputPort           : num_cc_num_cc_i
//
// No register generated

// -----------------------------------------------------------------------------
// Register prach_pat_en implementation
// -----------------------------------------------------------------------------

// prach_pat_en_prach_pat_en
//    bitfield description: Pattern Enable
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      prach_pat_en_prach_pat_en <= 1'h0;
   end
   else begin
      if (we_prach_pat_en) begin
         prach_pat_en_prach_pat_en <= din[0];
      end
   end

// -----------------------------------------------------------------------------
// Register prach_pb_sel implementation
// -----------------------------------------------------------------------------

// prach_pb_sel_prach_pb_sel
//    bitfield description: Pattern select
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      prach_pb_sel_prach_pb_sel <= 1'h0;
   end
   else begin
      if (we_prach_pb_sel) begin
         prach_pb_sel_prach_pb_sel <= din[0];
      end
   end

// -----------------------------------------------------------------------------
// Register hps_valid implementation
// -----------------------------------------------------------------------------

// hps_valid_hps_valid
//    bitfield description: Bit[0]- hps_valid
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h1

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      hps_valid_hps_valid <= 1'h1;
   end
   else begin
      if (we_hps_valid) begin
         hps_valid_hps_valid <= din[0];
      end
   end

// -----------------------------------------------------------------------------
// Register hps_config implementation
// -----------------------------------------------------------------------------

// hps_config_frame_structure
//    bitfield description: Bit[7:0]- frame_structure
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 8'hc0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      hps_config_frame_structure <= 8'hc0;
   end
   else begin
      if (we_hps_config) begin
         hps_config_frame_structure[7:0] <= din[7:0];
      end
   end

// -----------------------------------------------------------------------------
// Register short_prach_freq_offset implementation
// -----------------------------------------------------------------------------

// short_prach_freq_offset_short_prach_freq_offset
//    bitfield description: Bit[23:0]- short_prach_freq_offset
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 24'h0000e4

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      short_prach_freq_offset_short_prach_freq_offset <= 24'h0000e4;
   end
   else begin
      if (we_short_prach_freq_offset[0]) begin
         short_prach_freq_offset_short_prach_freq_offset[7:0] <= din[7:0];
      end
      if (we_short_prach_freq_offset[1]) begin
         short_prach_freq_offset_short_prach_freq_offset[15:8] <= din[15:8];
      end
      if (we_short_prach_freq_offset[2]) begin
         short_prach_freq_offset_short_prach_freq_offset[23:16] <= din[23:16];
      end
   end

// -----------------------------------------------------------------------------
// Register ifft_l1_rc_bw_sel implementation
// -----------------------------------------------------------------------------

// ifft_l1_rc_bw_sel_ifft_rc_bw_sel_l1
//    bitfield description: Bit[3:0]- RC bw sel for ifft l1
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 4'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ifft_l1_rc_bw_sel_ifft_rc_bw_sel_l1 <= 4'h0;
   end
   else begin
      if (we_ifft_l1_rc_bw_sel) begin
         ifft_l1_rc_bw_sel_ifft_rc_bw_sel_l1[3:0] <= din[3:0];
      end
   end

// -----------------------------------------------------------------------------
// Register ifft_l2_rc_bw_sel implementation
// -----------------------------------------------------------------------------

// ifft_l2_rc_bw_sel_ifft_rc_bw_sel_l2
//    bitfield description: Bit[3:0]- RC bw sel for ifft l2
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 4'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      ifft_l2_rc_bw_sel_ifft_rc_bw_sel_l2 <= 4'h0;
   end
   else begin
      if (we_ifft_l2_rc_bw_sel) begin
         ifft_l2_rc_bw_sel_ifft_rc_bw_sel_l2[3:0] <= din[3:0];
      end
   end

// -----------------------------------------------------------------------------
// Register fft_l1_rc_bw_sel implementation
// -----------------------------------------------------------------------------

// fft_l1_rc_bw_sel_fft_rc_bw_sel_l1
//    bitfield description: Bit[3:0]- RC bw sel for fft l1
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 4'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      fft_l1_rc_bw_sel_fft_rc_bw_sel_l1 <= 4'h0;
   end
   else begin
      if (we_fft_l1_rc_bw_sel) begin
         fft_l1_rc_bw_sel_fft_rc_bw_sel_l1[3:0] <= din[3:0];
      end
   end

// -----------------------------------------------------------------------------
// Register fft_l2_rc_bw_sel implementation
// -----------------------------------------------------------------------------

// fft_l2_rc_bw_sel_fft_rc_bw_sel_l2
//    bitfield description: Bit[3:0]- RC bw sel for fft l2
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 4'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      fft_l2_rc_bw_sel_fft_rc_bw_sel_l2 <= 4'h0;
   end
   else begin
      if (we_fft_l2_rc_bw_sel) begin
         fft_l2_rc_bw_sel_fft_rc_bw_sel_l2[3:0] <= din[3:0];
      end
   end

// -----------------------------------------------------------------------------
// Register short_prach_time_offset implementation
// -----------------------------------------------------------------------------

// short_prach_time_offset_short_prach_time_offset
//    bitfield description: Bit[31:0]- short_prach_time_offset
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 32'h00000484

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      short_prach_time_offset_short_prach_time_offset <= 32'h00000484;
   end
   else begin
      if (we_short_prach_time_offset[0]) begin
         short_prach_time_offset_short_prach_time_offset[7:0] <= din[7:0];
      end
      if (we_short_prach_time_offset[1]) begin
         short_prach_time_offset_short_prach_time_offset[15:8] <= din[15:8];
      end
      if (we_short_prach_time_offset[2]) begin
         short_prach_time_offset_short_prach_time_offset[23:16] <= din[23:16];
      end
      if (we_short_prach_time_offset[3]) begin
         short_prach_time_offset_short_prach_time_offset[31:24] <= din[31:24];
      end
   end

// -----------------------------------------------------------------------------
// Register short_prach_time_offset_bias implementation
// -----------------------------------------------------------------------------

// short_prach_time_offset_bias_short_prach_time_offset_bias
//    bitfield description: Bit[31:0]- short_prach_time_offset_bias
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 32'h000000dc

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      short_prach_time_offset_bias_short_prach_time_offset_bias <= 32'h000000dc;
   end
   else begin
      if (we_short_prach_time_offset_bias[0]) begin
         short_prach_time_offset_bias_short_prach_time_offset_bias[7:0] <= din[7:0];
      end
      if (we_short_prach_time_offset_bias[1]) begin
         short_prach_time_offset_bias_short_prach_time_offset_bias[15:8] <= din[15:8];
      end
      if (we_short_prach_time_offset_bias[2]) begin
         short_prach_time_offset_bias_short_prach_time_offset_bias[23:16] <= din[23:16];
      end
      if (we_short_prach_time_offset_bias[3]) begin
         short_prach_time_offset_bias_short_prach_time_offset_bias[31:24] <= din[31:24];
      end
   end

// -----------------------------------------------------------------------------
// Register short_prach_startsym_bias implementation
// -----------------------------------------------------------------------------

// short_prach_startsym_bias_short_prach_startsym_bias
//    bitfield description: Bit[31:0]- short_prach_startsym_bias
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 32'h00000000

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      short_prach_startsym_bias_short_prach_startsym_bias <= 32'h00000000;
   end
   else begin
      if (we_short_prach_startsym_bias[0]) begin
         short_prach_startsym_bias_short_prach_startsym_bias[7:0] <= din[7:0];
      end
      if (we_short_prach_startsym_bias[1]) begin
         short_prach_startsym_bias_short_prach_startsym_bias[15:8] <= din[15:8];
      end
      if (we_short_prach_startsym_bias[2]) begin
         short_prach_startsym_bias_short_prach_startsym_bias[23:16] <= din[23:16];
      end
      if (we_short_prach_startsym_bias[3]) begin
         short_prach_startsym_bias_short_prach_startsym_bias[31:24] <= din[31:24];
      end
   end

// -----------------------------------------------------------------------------
// Data read management
// -----------------------------------------------------------------------------

always @(*)
begin
   rdata_comb = 32'h00000000;
   if (re) begin
      case (addr)
         // Register frame_sync_frame_config: frame_sync_frame_config_dl_start (RW)
         //                                   frame_sync_frame_config_ul_start (RW)
         8'h00: begin
            rdata_comb[0] = frame_sync_frame_config_dl_start;
            rdata_comb[1] = frame_sync_frame_config_ul_start;
         end
         // Register dl_input_config: dl_input_config_dl_input_sample (RW)
         //                           dl_input_config_dl_input_sym (RW)
         //                           dl_input_config_dl_input_sfn (RW)
         //                           dl_input_config_dl_input_rfn (RW)
         8'h04: begin
            rdata_comb[15:0] = dl_input_config_dl_input_sample[15:0];
            rdata_comb[20:16] = dl_input_config_dl_input_sym[4:0];
            rdata_comb[24:21] = dl_input_config_dl_input_sfn[3:0];
            rdata_comb[25] = dl_input_config_dl_input_rfn;
         end
         // Register ul_input_config: ul_input_config_ul_input_sample (RW)
         //                           ul_input_config_ul_input_sym (RW)
         //                           ul_input_config_ul_input_sfn (RW)
         //                           ul_input_config_ul_input_rfn (RW)
         8'h08: begin
            rdata_comb[15:0] = ul_input_config_ul_input_sample[15:0];
            rdata_comb[20:16] = ul_input_config_ul_input_sym[4:0];
            rdata_comb[24:21] = ul_input_config_ul_input_sfn[3:0];
            rdata_comb[25] = ul_input_config_ul_input_rfn;
         end
         // Register reset_config: reset_config_soft_reset (RW)
         8'h0c: begin
            rdata_comb[0] = reset_config_soft_reset;
         end
         // Register bw_config_cc1: bw_config_cc1_bw_config_sel (RW)
         //                         bw_config_cc1_cc1_disable (RW)
         8'h10: begin
            rdata_comb[6:0] = bw_config_cc1_bw_config_sel[6:0];
            rdata_comb[7] = bw_config_cc1_cc1_disable;
         end
         // Register bw_config_cc2: bw_config_cc2_bw_config_sel (RW)
         //                         bw_config_cc2_cc2_disable (RW)
         8'h14: begin
            rdata_comb[6:0] = bw_config_cc2_bw_config_sel[6:0];
            rdata_comb[7] = bw_config_cc2_cc2_disable;
         end
         // Register prb_blanking_ctrl: prb_blanking_ctrl_blanking_dis (RW)
         8'h18: begin
            rdata_comb[0] = prb_blanking_ctrl_blanking_dis;
         end
         // Register cp_length: cp_length_cp_length (RW)
         8'h1c: begin
            rdata_comb[10:0] = cp_length_cp_length[10:0];
         end
         // Register fft_size: fft_size_fft_size (RW)
         8'h20: begin
            rdata_comb[3:0] = fft_size_fft_size[3:0];
         end
         // Register ifft_l1_control: ifft_l1_control_mux_select_l1 (RW)
         //                           ifft_l1_control_ifft_dc_sc_en_l1 (RW)
         //                           ifft_l1_control_ifft_rc_enable_l1 (RW)
         8'h24: begin
            rdata_comb[0] = ifft_l1_control_mux_select_l1;
            rdata_comb[1] = ifft_l1_control_ifft_dc_sc_en_l1;
            rdata_comb[2] = ifft_l1_control_ifft_rc_enable_l1;
         end
         // Register ifft_gain_l1: ifft_gain_l1_ifft_gain_l1 (RW)
         8'h28: begin
            rdata_comb[31:0] = ifft_gain_l1_ifft_gain_l1[31:0];
         end
         // Register ifft_shift_l1: ifft_shift_l1_ifft_shift_l1 (RW)
         8'h2c: begin
            rdata_comb[3:0] = ifft_shift_l1_ifft_shift_l1[3:0];
         end
         // Register ifft_mux_const_data_l1: ifft_mux_const_data_l1_ifft_mux_constant_l1 (RW)
         8'h30: begin
            rdata_comb[15:0] = ifft_mux_const_data_l1_ifft_mux_constant_l1[15:0];
         end
         // Register ifft_l2_control: ifft_l2_control_mux_select_l2 (RW)
         //                           ifft_l2_control_ifft_dc_sc_en_l2 (RW)
         //                           ifft_l2_control_ifft_rc_enable_l2 (RW)
         8'h38: begin
            rdata_comb[0] = ifft_l2_control_mux_select_l2;
            rdata_comb[1] = ifft_l2_control_ifft_dc_sc_en_l2;
            rdata_comb[2] = ifft_l2_control_ifft_rc_enable_l2;
         end
         // Register ifft_gain_l2: ifft_gain_l2_ifft_gain_l2 (RW)
         8'h3c: begin
            rdata_comb[31:0] = ifft_gain_l2_ifft_gain_l2[31:0];
         end
         // Register ifft_shift_l2: ifft_shift_l2_ifft_shift_l2 (RW)
         8'h40: begin
            rdata_comb[3:0] = ifft_shift_l2_ifft_shift_l2[3:0];
         end
         // Register ifft_mux_const_data_l2: ifft_mux_const_data_l2_ifft_mux_constant_l2 (RW)
         8'h44: begin
            rdata_comb[15:0] = ifft_mux_const_data_l2_ifft_mux_constant_l2[15:0];
         end
         // Register fft_l1_control: fft_l1_control_fft_dc_sc_en_l1 (RW)
         //                          fft_l1_control_ul_hcs_bypass_l1 (RW)
         //                          fft_l1_control_fft_rc_enable_l1 (RW)
         8'h4c: begin
            rdata_comb[0] = fft_l1_control_fft_dc_sc_en_l1;
            rdata_comb[1] = fft_l1_control_ul_hcs_bypass_l1;
            rdata_comb[2] = fft_l1_control_fft_rc_enable_l1;
         end
         // Register fft_gain_l1: fft_gain_l1_fft_gain_l1 (RW)
         8'h50: begin
            rdata_comb[31:0] = fft_gain_l1_fft_gain_l1[31:0];
         end
         // Register fft_shift_l1: fft_shift_l1_fft_shift_l1 (RW)
         8'h54: begin
            rdata_comb[3:0] = fft_shift_l1_fft_shift_l1[3:0];
         end
         // Register fft_l2_control: fft_l2_control_fft_dc_sc_en_l2 (RW)
         //                          fft_l2_control_ul_hcs_bypass_l2 (RW)
         //                          fft_l2_control_fft_rc_enable_l2 (RW)
         8'h58: begin
            rdata_comb[0] = fft_l2_control_fft_dc_sc_en_l2;
            rdata_comb[1] = fft_l2_control_ul_hcs_bypass_l2;
            rdata_comb[2] = fft_l2_control_fft_rc_enable_l2;
         end
         // Register fft_gain_l2: fft_gain_l2_fft_gain_l2 (RW)
         8'h5c: begin
            rdata_comb[31:0] = fft_gain_l2_fft_gain_l2[31:0];
         end
         // Register fft_shift_l2: fft_shift_l2_fft_shift_l2 (RW)
         8'h60: begin
            rdata_comb[3:0] = fft_shift_l2_fft_shift_l2[3:0];
         end
         // Register lpbk_en: lpbk_en_ifft_fft_lpbk_en (RW)
         8'h64: begin
            rdata_comb[0] = lpbk_en_ifft_fft_lpbk_en;
			rdata_comb[1] = lpbk_en_duc_ddc_lpbk_en;
         end
         // Register c_hps: c_hps_c_hps (RW)
         8'h68: begin
            rdata_comb[0] = c_hps_c_hps;
         end
         // Register prach_sel: prach_sel_short_long_prach_sel (RO)
         8'h6c: begin
            rdata_comb[0] = prach_sel_short_long_prach_sel_i;
         end
         // Register long_prach_freq_offset: long_prach_freq_offset_long_prach_freq_offset (RO)
         8'h70: begin
            rdata_comb[23:0] = long_prach_freq_offset_long_prach_freq_offset_i[23:0];
         end
         // Register long_prach_filt_flush_en: long_prach_filt_flush_en_lprach1_filt_flush_en (RW)
         //                                    long_prach_filt_flush_en_lprach2_filt_flush_en (RW)
         8'h74: begin
            rdata_comb[0] = long_prach_filt_flush_en_lprach1_filt_flush_en;
            rdata_comb[1] = long_prach_filt_flush_en_lprach2_filt_flush_en;
         end
         // Register long_prach_version: long_prach_version_long_prach_version (RO)
         8'h78: begin
            rdata_comb[31:0] = long_prach_version_long_prach_version_i[31:0];
         end
         // Register num_cc: num_cc_num_cc (RO)
         8'h7c: begin
            rdata_comb[0] = num_cc_num_cc_i;
         end
         // Register prach_pat_en: prach_pat_en_prach_pat_en (RW)
         8'h80: begin
            rdata_comb[0] = prach_pat_en_prach_pat_en;
         end
         // Register prach_pb_sel: prach_pb_sel_prach_pb_sel (RW)
         8'h84: begin
            rdata_comb[0] = prach_pb_sel_prach_pb_sel;
         end
         // Register hps_valid: hps_valid_hps_valid (RW)
         8'h88: begin
            rdata_comb[0] = hps_valid_hps_valid;
         end
         // Register hps_config: hps_config_frame_structure (RW)
         8'h8c: begin
            rdata_comb[7:0] = hps_config_frame_structure[7:0];
         end
         // Register short_prach_freq_offset: short_prach_freq_offset_short_prach_freq_offset (RW)
         8'h90: begin
            rdata_comb[23:0] = short_prach_freq_offset_short_prach_freq_offset[23:0];
         end
         // Register ifft_l1_rc_bw_sel: ifft_l1_rc_bw_sel_ifft_rc_bw_sel_l1 (RW)
         8'h94: begin
            rdata_comb[3:0] = ifft_l1_rc_bw_sel_ifft_rc_bw_sel_l1[3:0];
         end
         // Register ifft_l2_rc_bw_sel: ifft_l2_rc_bw_sel_ifft_rc_bw_sel_l2 (RW)
         8'h98: begin
            rdata_comb[3:0] = ifft_l2_rc_bw_sel_ifft_rc_bw_sel_l2[3:0];
         end
         // Register fft_l1_rc_bw_sel: fft_l1_rc_bw_sel_fft_rc_bw_sel_l1 (RW)
         8'h9c: begin
            rdata_comb[3:0] = fft_l1_rc_bw_sel_fft_rc_bw_sel_l1[3:0];
         end
         // Register fft_l2_rc_bw_sel: fft_l2_rc_bw_sel_fft_rc_bw_sel_l2 (RW)
         8'ha0: begin
            rdata_comb[3:0] = fft_l2_rc_bw_sel_fft_rc_bw_sel_l2[3:0];
         end
         // Register short_prach_time_offset: short_prach_time_offset_short_prach_time_offset (RW)
         8'ha4: begin
            rdata_comb[31:0] = short_prach_time_offset_short_prach_time_offset[31:0];
         end
         // Register short_prach_time_offset_bias: short_prach_time_offset_bias_short_prach_time_offset_bias (RW)
         8'ha8: begin
            rdata_comb[31:0] = short_prach_time_offset_bias_short_prach_time_offset_bias[31:0];
         end
         // Register short_prach_startsym_bias: short_prach_startsym_bias_short_prach_startsym_bias (RW)
         8'hac: begin
            rdata_comb[31:0] = short_prach_startsym_bias_short_prach_startsym_bias[31:0];
         end
         default: begin
            rdata_comb = 32'h00000000;
         end
      endcase
   end
end

endmodule