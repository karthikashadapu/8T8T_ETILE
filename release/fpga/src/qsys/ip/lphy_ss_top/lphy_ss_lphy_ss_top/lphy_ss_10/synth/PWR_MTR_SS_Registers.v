// -----------------------------------------------------------------------------
//  Generated by Magillem, from Arteris IPD division
//  Version: 5.16.0 (20230705092541_5.16.0)
//  Date   : 2024-11-12 05:02:48
// -----------------------------------------------------------------------------
//  Verilog Register Bank
// -----------------------------------------------------------------------------
//  Component Name: FFT_PWR_MTR_SS_Registers_L1
//  File Ref      : /nfs/site/disks/ceg_user_bkhantwa/ipxact/ip_xact_rdl/csrgen_output/_workspace_mrv_gen_py_/xmlProject/_local_copy_Vendor_Library_FFT_PWR_MTR_SS_Registers_L1_1.0.xml
//  Protocol      : AVALON
//  Wait State    : WS1_OUTPUT
// -----------------------------------------------------------------------------

module PWR_MTR_SS_Registers(

   // pwr_mtr_control_reg.mode
   output reg [3:0] pwr_mtr_control_reg_mode,
   // pwr_mtr_control_reg.StartnStop
   output reg pwr_mtr_control_reg_StartnStop,
   // pwr_mtr_control_reg.IRQ_Enable
   output reg pwr_mtr_control_reg_IRQ_Enable,
   // pwr_mtr_control_reg.DL_pwr_en
   output reg [1:0] pwr_mtr_control_reg_DL_pwr_en,
   // pwr_mtr_control_reg.UL_pwr_en
   output reg [1:0] pwr_mtr_control_reg_UL_pwr_en,
   // pwr_mtr_control_reg.control_reset
   output reg pwr_mtr_control_reg_control_reset,
   // pwr_mtr_status_reg.data_status
   input wire [1:0] pwr_mtr_status_reg_data_status_i,
   // pwr_mtr_status_reg.saturation
   input wire [1:0] pwr_mtr_status_reg_saturation_i,
   // pwr_mtr_status_reg.debug_state
   input wire [3:0] pwr_mtr_status_reg_debug_state_i,
   // pwr_mtr_status_reg.reserved1
   input wire [15:0] pwr_mtr_status_reg_reserved1_i,
   // pwr_mtr_compute_time.comp_time
   output reg [31:0] pwr_mtr_compute_time_comp_time,
   // pwr_mtr_intr_mask_reg.Error
   output reg pwr_mtr_intr_mask_reg_Error,
   // pwr_mtr_intr_mask_reg.data_ready
   output reg pwr_mtr_intr_mask_reg_data_ready,

   // Bus interface
   input wire clk,
   input wire reset,
   input wire [31:0] writedata,
   input wire read,
   input wire write,
   input wire [3:0] byteenable,
   output reg [31:0] readdata,
   output reg readdatavalid,
   input wire [3:0] address
);

wire reset_n = !reset;

// -----------------------------------------------------------------------------
// Protocol management
// -----------------------------------------------------------------------------

reg [31:0] rdata_comb;
always @(negedge reset_n, posedge clk)
   if (!reset_n) readdata[31:0] <= 32'h00000000; else readdata[31:0] <= rdata_comb[31:0];

// Read data is always valid the cycle after read transaction is asserted
always @(negedge reset_n, posedge clk)
   if (!reset_n) readdatavalid <= 1'b0; else readdatavalid <= read;

wire we = write;
wire re = read;
wire [3:0] addr = address[3:0];
wire [31:0] din = writedata[31:0];

// -----------------------------------------------------------------------------
// Write byte enables
// -----------------------------------------------------------------------------

// Register pwr_mtr_control_reg
wire [3:0] we_pwr_mtr_control_reg = we & (addr[3:0] == 4'h0) ? byteenable[3:0] : {4{1'b0}};
// Register pwr_mtr_compute_time
wire [3:0] we_pwr_mtr_compute_time = we & (addr[3:0] == 4'h8) ? byteenable[3:0] : {4{1'b0}};
// Register pwr_mtr_intr_mask_reg
wire we_pwr_mtr_intr_mask_reg = we & (addr[3:0] == 4'hc) ? byteenable[0] : 1'b0;

// -----------------------------------------------------------------------------
// Read byte enables
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Register pwr_mtr_control_reg implementation
// -----------------------------------------------------------------------------

// pwr_mtr_control_reg_mode
//    bitfield description: control_register_pwr_mode
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 4'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      pwr_mtr_control_reg_mode <= 4'h0;
   end
   else begin
      if (we_pwr_mtr_control_reg[0]) begin
         pwr_mtr_control_reg_mode[3:0] <= din[3:0];
      end
   end

// pwr_mtr_control_reg_StartnStop
//    bitfield description: control_register_start_nstop
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      pwr_mtr_control_reg_StartnStop <= 1'h0;
   end
   else begin
      if (we_pwr_mtr_control_reg[0]) begin
         pwr_mtr_control_reg_StartnStop <= din[4];
      end
   end

// pwr_mtr_control_reg_IRQ_Enable
//    bitfield description: control_register_irq_enable
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      pwr_mtr_control_reg_IRQ_Enable <= 1'h0;
   end
   else begin
      if (we_pwr_mtr_control_reg[0]) begin
         pwr_mtr_control_reg_IRQ_Enable <= din[5];
      end
   end

// pwr_mtr_control_reg_DL_pwr_en
//    bitfield description: control_register_dl_pwr_enable
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 2'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      pwr_mtr_control_reg_DL_pwr_en <= 2'h0;
   end
   else begin
      if (we_pwr_mtr_control_reg[0]) begin
         pwr_mtr_control_reg_DL_pwr_en[1:0] <= din[7:6];
      end
   end

// pwr_mtr_control_reg_UL_pwr_en
//    bitfield description: control_register_ul_pwr_enable
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 2'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      pwr_mtr_control_reg_UL_pwr_en <= 2'h0;
   end
   else begin
      if (we_pwr_mtr_control_reg[1]) begin
         pwr_mtr_control_reg_UL_pwr_en[1:0] <= din[9:8];
      end
   end

// pwr_mtr_control_reg_control_reset
//    bitfield description: control_register_reset
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      pwr_mtr_control_reg_control_reset <= 1'h0;
   end
   else begin
      if (we_pwr_mtr_control_reg[3]) begin
         pwr_mtr_control_reg_control_reset <= din[31];
      end
   end

// -----------------------------------------------------------------------------
// Register pwr_mtr_status_reg implementation
// -----------------------------------------------------------------------------

// pwr_mtr_status_reg_data_status
//    bitfield description: status_register_data_status
//    customType          : RO
//    hwAccess            : WO
//    reset value         : 2'h0
//    inputPort           : pwr_mtr_status_reg_data_status_i
//
// No register generated

// pwr_mtr_status_reg_saturation
//    bitfield description: status_register_saturation
//    customType          : RO
//    hwAccess            : WO
//    reset value         : 2'h0
//    inputPort           : pwr_mtr_status_reg_saturation_i
//
// No register generated

// pwr_mtr_status_reg_debug_state
//    bitfield description: status_register_debug_state
//    customType          : RO
//    hwAccess            : WO
//    reset value         : 4'h0
//    inputPort           : pwr_mtr_status_reg_debug_state_i
//
// No register generated

// pwr_mtr_status_reg_reserved1
//    bitfield description: status_register_reserved1
//    customType          : RO
//    hwAccess            : WO
//    reset value         : 16'h0000
//    inputPort           : pwr_mtr_status_reg_reserved1_i
//
// No register generated

// -----------------------------------------------------------------------------
// Register pwr_mtr_compute_time implementation
// -----------------------------------------------------------------------------

// pwr_mtr_compute_time_comp_time
//    bitfield description: longtermtime_symb_control_sig
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 32'h00000000

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      pwr_mtr_compute_time_comp_time <= 32'h00000000;
   end
   else begin
      if (we_pwr_mtr_compute_time[0]) begin
         pwr_mtr_compute_time_comp_time[7:0] <= din[7:0];
      end
      if (we_pwr_mtr_compute_time[1]) begin
         pwr_mtr_compute_time_comp_time[15:8] <= din[15:8];
      end
      if (we_pwr_mtr_compute_time[2]) begin
         pwr_mtr_compute_time_comp_time[23:16] <= din[23:16];
      end
      if (we_pwr_mtr_compute_time[3]) begin
         pwr_mtr_compute_time_comp_time[31:24] <= din[31:24];
      end
   end

// -----------------------------------------------------------------------------
// Register pwr_mtr_intr_mask_reg implementation
// -----------------------------------------------------------------------------

// pwr_mtr_intr_mask_reg_Error
//    bitfield description: interrupt_mask_error
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      pwr_mtr_intr_mask_reg_Error <= 1'h0;
   end
   else begin
      if (we_pwr_mtr_intr_mask_reg) begin
         pwr_mtr_intr_mask_reg_Error <= din[0];
      end
   end

// pwr_mtr_intr_mask_reg_data_ready
//    bitfield description: interrupt_mask_register_data_ready
//    customType          : RW
//    hwAccess            : RO
//    reset value         : 1'h0

always @(negedge reset_n, posedge clk)
   if (!reset_n) begin
      pwr_mtr_intr_mask_reg_data_ready <= 1'h0;
   end
   else begin
      if (we_pwr_mtr_intr_mask_reg) begin
         pwr_mtr_intr_mask_reg_data_ready <= din[1];
      end
   end

// -----------------------------------------------------------------------------
// Data read management
// -----------------------------------------------------------------------------

always @(*)
begin
   rdata_comb = 32'h00000000;
   if (re) begin
      case (addr)
         // Register pwr_mtr_control_reg: pwr_mtr_control_reg_mode (RW)
         //                               pwr_mtr_control_reg_StartnStop (RW)
         //                               pwr_mtr_control_reg_IRQ_Enable (RW)
         //                               pwr_mtr_control_reg_DL_pwr_en (RW)
         //                               pwr_mtr_control_reg_UL_pwr_en (RW)
         //                               pwr_mtr_control_reg_control_reset (RW)
         4'h0: begin
            rdata_comb[3:0] = pwr_mtr_control_reg_mode[3:0];
            rdata_comb[4] = pwr_mtr_control_reg_StartnStop;
            rdata_comb[5] = pwr_mtr_control_reg_IRQ_Enable;
            rdata_comb[7:6] = pwr_mtr_control_reg_DL_pwr_en[1:0];
            rdata_comb[9:8] = pwr_mtr_control_reg_UL_pwr_en[1:0];
            rdata_comb[31] = pwr_mtr_control_reg_control_reset;
         end
         // Register pwr_mtr_status_reg: pwr_mtr_status_reg_data_status (RO)
         //                              pwr_mtr_status_reg_saturation (RO)
         //                              pwr_mtr_status_reg_debug_state (RO)
         //                              pwr_mtr_status_reg_reserved1 (RO)
         4'h4: begin
            rdata_comb[1:0] = pwr_mtr_status_reg_data_status_i[1:0];
            rdata_comb[3:2] = pwr_mtr_status_reg_saturation_i[1:0];
            rdata_comb[7:4] = pwr_mtr_status_reg_debug_state_i[3:0];
			rdata_comb[15:8] = 8'b0;
            rdata_comb[31:16] = pwr_mtr_status_reg_reserved1_i[15:0];
			
         end
         // Register pwr_mtr_compute_time: pwr_mtr_compute_time_comp_time (RW)
         4'h8: begin
            rdata_comb[31:0] = pwr_mtr_compute_time_comp_time[31:0];
         end
         // Register pwr_mtr_intr_mask_reg: pwr_mtr_intr_mask_reg_Error (RW)
         //                                 pwr_mtr_intr_mask_reg_data_ready (RW)
         4'hc: begin
            rdata_comb[0] = pwr_mtr_intr_mask_reg_Error;
            rdata_comb[1] = pwr_mtr_intr_mask_reg_data_ready;
         end
         default: begin
            rdata_comb = 32'h00000000;
         end
      endcase
   end
end

endmodule