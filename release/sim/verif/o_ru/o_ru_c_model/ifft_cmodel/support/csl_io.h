/**
 * This file contains ATB/debug specific functions/structs
 * that are not required by the software model itself.
 */
#if defined(CSL_USE_PRAGMA_ONCE)
#pragma once
#endif

#ifndef CSL_IO_H
#define CSL_IO_H

#include "csl.h"
#include <fstream>
#include <stdarg.h>
#include <string.h>
#include <vector>

#ifdef CSL_DEBUG_DUMP_ENABLED
#include <assert.h>
#include <map>
#endif

inline std::string csl_format(const char *msg, ...)
{
    char buffer[1024];
    va_list args;
    va_start(args, msg);
    vsnprintf(buffer, 1024, msg, args);
    va_end(args);
    return buffer;
}

inline void csl_fmt_error(const char *msg, ...)
{
    char buffer[1024];
    va_list args;
    va_start(args, msg);
    vsnprintf(buffer, 1024, msg, args);
    va_end(args);
    csl_error(buffer);
}

inline void csl_fmt_warning(const char *msg, ...)
{
    char buffer[1024];
    va_list args;
    va_start(args, msg);
    vsnprintf(buffer, 1024, msg, args);
    va_end(args);
    csl_warning(buffer);
}

inline void csl_fmt_info(const char *msg, ...)
{
    char buffer[1024];
    va_list args;
    va_start(args, msg);
    vsnprintf(buffer, 1024, msg, args);
    va_end(args);
    csl_info(buffer);
}

/**
 * Returns the binary representation of param 'a' as a string,
 * up to the param 'width' number of bits.
 * e.g: toBinary(2, 3) returns "010", toBinary(2, 2) returns "10", toBinary(2, 1) returns "0"
 */
extern std::string csl_to_binary(uint64_t a, unsigned width);
/**
 * Compares two .stm files.
 * Returns true if the result entries are a subset of the reference entries (at some offset).
 * This allows for the latency differences in the C model/Simulink simulation.
 */
extern bool csl_compare_stm_files(const char *resultFileName, const char *referenceFileName);

/**
 * Stimulus file writer for ATBs
 * The written files are used for comparison against the reference Simulink result
 */
class csl_output_stimulus_file
{
  public:
    csl_output_stimulus_file() = default;
    csl_output_stimulus_file(const char *filename);
    csl_output_stimulus_file(const csl_output_stimulus_file &) = delete;
    ~csl_output_stimulus_file();

    void open(const char *filename);

    /** Writes out the value to the file */
    void write_stm_data(int64_t v, int64_t width);
    void write_stm_data(int32_t v, int64_t width);
    void write_stm_data(int16_t v, int64_t width);
    void write_stm_data(int8_t v, int64_t width);
    void write_stm_data(double v);
    void write_stm_data(float v);

#ifdef CSL_USE_MPIR
    /** Writes out the value to the file */
    void write_stm_data(csl_mp_int v, int64_t width);
    void write_stm_data(const uint32_t *v, int64_t width, size_t count);
#endif

    /** Proceed to the next line/row of output values */
    void next_line();
    /** Get the total number of lines/rows written */
    size_t get_line_count() const;

  private:
    void write_stm_data_impl(int64_t v, int64_t width);

  private:
    size_t m_line_count = 0;
    std::ofstream m_file;
};

/**
 * Reads the stimulus files generated by DSPBA (*.stm).
 * Files are read line-by-line by using the get functions to read a line then calling next_line().
 */
class csl_stimulus_file
{
  public:
    enum StimulusFormat
    {
        SIGNED,
        BINARY,
        UNKNOWN
    };

  private:
    /**
     * Gets the next 32-bit integer.
     * @returns True if a value was successfully read
     */
    bool get_u32(uint32_t &value);
    void reset_file();
    void discover_format();

  public:
    csl_stimulus_file();
    /** The same as calling the default constructor followed by open() */
    csl_stimulus_file(const std::string &fileName, StimulusFormat format);
    csl_stimulus_file(const csl_stimulus_file &) = delete;
    ~csl_stimulus_file();

    /** Attempts to close the open file */
    void close();

    /**
     * Opens a new file
     * @param fileName Path of the stimulus file to be opened
     * @returns True if the file was opened successfully
     */
    bool open(const std::string &fileName, StimulusFormat format);

    /** Returns true if a file is currently open */
    bool is_open() const;

    /** Returns true if the current row of the stimulus file has been read in full */
    bool is_line_fully_read() const;

    /**
     * Progresses to the next line, warning if the previous has not been read. Must be called first after open().
     * @returns True if a new line was successfully read
     */
    bool next_line();

    /**
     * Skips the next n lines. Must be called first after open().
     * @returns True if all lines were successfully read and skipped
     */
    bool skip_lines(size_t n);

    /**
     * Skips the next line, warning if the previous has not been read. Must be called first after open().
     * @returns True if a new line was successfully read and skipped
     */
    bool skip_line();

    /**
     * Skips a number of entries
     * @param count the number of entries to skip
     */
    void skip(int count);

    /**
     * Gets the next bit_width integer.
     * @returns True if a value was successfully read
     */
    bool get(int64_t &value, size_t bit_width);
    bool get(int32_t &value, size_t bit_width);
    bool get(int16_t &value, size_t bit_width);
    bool get(int8_t &value, size_t bit_width);

    /**
     * Gets the next double-precision value (reading 64 bits).
     * @returns True if a value was successfully read
     */
    bool get(double &value);

    /**
     * Gets the next single-precision value (reading 32 bits).
     * @returns True if a value was successfully read
     */
    bool get(float &value);

#ifdef CSL_USE_MPIR
    /**
     * Gets the next arbitrary precision unsigned integer
     * @returns True if a value was successfully read
     * @param var The mpz_t to store the result in
     * @param bit_width the number of bits to read for the variable
     */
    bool get(csl_mp_int &var, size_t bit_width);
    bool get(uint32_t *values, size_t bit_width, size_t capacity);
#endif

  private:
    std::ifstream m_stm_file;
    std::vector<std::string> m_current_line;
    uint32_t m_line_position;
    StimulusFormat m_stm_format;
};

#ifdef CSL_DEBUG_DUMP_ENABLED

class csl_mp_int;

/**
 * Creates a binary dump file with a model's memory state for comparison to the DSPBA
 * bit-accurate model. This is intended for internal development usage only.
 */
class csl_dump_file
{
    static const int32_t ID_ROWS = 0x524F5753;
    static const int32_t ID_DUMP = 0x44554D50;
    static const int32_t ID_LOCS = 0x4C4F4353;
    static const int32_t ID_SEGS = 0x53454753;
    static const int32_t ID_STEP = 0x53544550;
    static const int32_t ID_DATA = 0x44415441;
    static const int32_t ID_CYCL = 0x4359434C;

    struct csl_header_writer
    {
      public:
        void write(const void *data, size_t length);
        void write(int data);
        void write(size_t data);
        void write(int64_t data);
        void write_string(const std::string &data);

        const size_t get_size() const;
        const uint8_t *get_data() const;

      private:
        size_t m_pos = 0;
        std::vector<uint8_t> m_data;
    };

  public:
    csl_dump_file();
    ~csl_dump_file();

    /** Opens a dump file for output */
    void open(const std::string &file);
    /** Flush and close the file */
    void close();
    /** Sets a name for a given memory location for assistance in debugging */
    void set_location_info(size_t location, int bitWidth, const char *name);
    /** Sets current cycle for assistance in debugging */
    void set_current_cycle(int64_t value);

    /** Opens a dump file for output */
    void add_row(int64_t *nativeData, size_t nativeCount, csl_mp_int *wideData, size_t wideCount,
                 const char *step_name);
    /** Opens a dump file for output with additional cycle information */
    void add_row(int64_t *nativeData, size_t nativeCount, csl_mp_int *wideData, size_t wideCount, const char *step_name,
                 int64_t *seg_cycles, size_t seg_cycle_count, int64_t update_cycle);

  private:
    csl_header_writer m_row_data;

    int64_t m_current_cycle;
    std::vector<size_t> m_row_offsets;
    std::vector<std::string> m_row_names;
    struct Info
    {
        std::string m_name;
        int m_bit_width;
    };
    std::map<size_t, Info> m_location_info;

    std::string m_file_name;
};

#endif

#endif // CSL_IO_H